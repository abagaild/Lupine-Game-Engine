#include "lupine/visualscripting/CodeGenerator.h"
#include "lupine/visualscripting/VScriptGraph.h"
#include "lupine/visualscripting/VScriptNode.h"
#include "lupine/visualscripting/VScriptConnection.h"
#include <sstream>
#include <algorithm>

namespace Lupine {

CodeGenerator::CodeGenerator()
    : m_include_debug_comments(true)
    , m_indentation("    ")  // 4 spaces
{
}

std::string CodeGenerator::GenerateCode(const VScriptGraph& graph) const {
    std::vector<std::string> lines;
    
    // Generate header and imports
    auto header_lines = GenerateHeader();
    lines.insert(lines.end(), header_lines.begin(), header_lines.end());
    
    auto import_lines = GenerateImports();
    lines.insert(lines.end(), import_lines.begin(), import_lines.end());
    
    // Add blank line
    lines.push_back("");
    
    // Generate class definition
    auto class_lines = GenerateClassDefinition(graph);
    lines.insert(lines.end(), class_lines.begin(), class_lines.end());
    
    // Convert lines to single string
    std::ostringstream oss;
    for (size_t i = 0; i < lines.size(); ++i) {
        oss << lines[i];
        if (i < lines.size() - 1) {
            oss << "\n";
        }
    }
    
    return oss.str();
}

std::vector<std::string> CodeGenerator::GenerateHeader() const {
    std::vector<std::string> lines;
    
    if (m_include_debug_comments) {
        lines.push_back("# Generated by Lupine Visual Scripter");
        lines.push_back("# Do not edit this file manually - changes will be overwritten");
        lines.push_back("");
    }
    
    return lines;
}

std::vector<std::string> CodeGenerator::GenerateImports() const {
    std::vector<std::string> lines;
    
    lines.push_back("import math");
    lines.push_back("from typing import Any, Optional");
    
    if (m_include_debug_comments) {
        lines.push_back("# Add additional imports as needed");
    }
    
    return lines;
}

std::vector<std::string> CodeGenerator::GenerateClassDefinition(const VScriptGraph& graph) const {
    std::vector<std::string> lines;
    
    lines.push_back("class VisualScript:");
    lines.push_back(ApplyIndentation("\"\"\"Generated visual script class\"\"\"", 1));
    lines.push_back("");
    
    // Constructor
    lines.push_back(ApplyIndentation("def __init__(self):", 1));
    lines.push_back(ApplyIndentation("\"\"\"Initialize the visual script\"\"\"", 2));
    
    // Generate variable declarations
    auto var_lines = GenerateVariableDeclarations(graph);
    if (var_lines.empty()) {
        lines.push_back(ApplyIndentation("pass", 2));
    } else {
        lines.insert(lines.end(), var_lines.begin(), var_lines.end());
    }
    lines.push_back("");
    
    // Generate lifecycle methods
    std::vector<std::string> lifecycle_methods = {
        "on_awake", "on_ready", "on_update", "on_physics_process", "on_input", "on_destroy"
    };
    
    for (const auto& method : lifecycle_methods) {
        lines.push_back(ApplyIndentation("def " + method + "(self):", 1));
        lines.push_back(ApplyIndentation("\"\"\"" + method + " lifecycle method\"\"\"", 2));
        
        // Find entry points for this method
        auto entry_points = graph.GetEntryPoints();
        bool found_method = false;
        
        for (auto* node : entry_points) {
            if (node->GetType() == method || 
                (node->GetType() == "Event" && node->GetProperty("event_type") == method)) {
                
                std::unordered_set<std::string> visited;
                auto method_lines = GenerateExecutionPath(graph, node, visited, 2);
                lines.insert(lines.end(), method_lines.begin(), method_lines.end());
                found_method = true;
                break;
            }
        }
        
        if (!found_method) {
            lines.push_back(ApplyIndentation("pass", 2));
        }
        
        lines.push_back("");
    }
    
    return lines;
}

std::vector<std::string> CodeGenerator::GenerateVariableDeclarations(const VScriptGraph& graph) const {
    std::vector<std::string> lines;
    
    // Find all variable nodes and declare them
    auto nodes = graph.GetNodes();
    for (auto* node : nodes) {
        if (node->GetCategory() == VScriptNodeCategory::Variable) {
            if (node->GetType() == "SetVariable" || node->GetType() == "GetVariable") {
                std::string var_name = node->GetProperty("variable_name");
                std::string var_type = node->GetProperty("variable_type", "Any");
                std::string default_value = node->GetProperty("default_value", "None");
                
                if (!var_name.empty()) {
                    std::string line = "self." + var_name + " = " + default_value;
                    if (m_include_debug_comments) {
                        line += "  # " + var_type;
                    }
                    lines.push_back(ApplyIndentation(line, 2));
                }
            }
        }
    }
    
    return lines;
}

std::vector<std::string> CodeGenerator::GenerateExecutionPath(const VScriptGraph& graph,
                                                             VScriptNode* start_node,
                                                             std::unordered_set<std::string>& visited,
                                                             int indent_level) const {
    std::vector<std::string> lines;

    if (!start_node || visited.count(start_node->GetId())) {
        return lines;
    }

    visited.insert(start_node->GetId());

    if (m_include_debug_comments) {
        lines.push_back(ApplyIndentation("# " + start_node->GetDisplayName(), indent_level));
    }

    // Generate variable assignments for input pins that have connections
    auto input_assignments = GenerateInputAssignments(graph, start_node, indent_level);
    lines.insert(lines.end(), input_assignments.begin(), input_assignments.end());

    // Generate code for this node with enhanced context
    auto node_lines = GenerateNodeCode(graph, start_node, indent_level);
    lines.insert(lines.end(), node_lines.begin(), node_lines.end());

    // Generate variable assignments for output pins
    auto output_assignments = GenerateOutputAssignments(graph, start_node, indent_level);
    lines.insert(lines.end(), output_assignments.begin(), output_assignments.end());

    // Follow execution flow to next node
    VScriptNode* next_node = GetNextExecutionNode(graph, start_node);
    if (next_node) {
        auto next_lines = GenerateExecutionPath(graph, next_node, visited, indent_level);
        lines.insert(lines.end(), next_lines.begin(), next_lines.end());
    }

    return lines;
}

VScriptNode* CodeGenerator::GetNextExecutionNode(const VScriptGraph& graph, 
                                                VScriptNode* current_node,
                                                const std::string& output_pin_name) const {
    if (!current_node) {
        return nullptr;
    }
    
    auto connections = graph.GetConnectionsFromPin(current_node->GetId(), output_pin_name);
    if (connections.empty()) {
        return nullptr;
    }
    
    // Return the first connected node (assuming single execution flow)
    return graph.GetNode(connections[0]->GetToNodeId());
}

std::string CodeGenerator::GetInputValue(const VScriptGraph& graph,
                                        VScriptNode* node,
                                        const std::string& pin_name) const {
    if (!node) {
        return "None";
    }

    // Check if there's a connection to this input pin
    auto connections = graph.GetConnectionsToPin(node->GetId(), pin_name);
    if (!connections.empty()) {
        // Get value from connected output pin
        VScriptConnection* connection = connections[0];
        VScriptNode* source_node = graph.GetNode(connection->GetFromNodeId());
        if (source_node) {
            // Generate variable name for the connected output
            std::string var_name = GenerateVariableName(source_node, connection->GetFromPinName());
            return var_name;
        }
    }

    // Use default value from the pin
    VScriptPin* pin = node->GetPin(pin_name);
    if (pin) {
        std::string default_val = pin->GetDefaultValue();
        if (!default_val.empty()) {
            // Format the default value based on data type
            return FormatDefaultValue(default_val, pin->GetDataType());
        }
    }

    return "None";
}

std::string CodeGenerator::ApplyIndentation(const std::string& line, int indent_level) const {
    std::string result;
    for (int i = 0; i < indent_level; ++i) {
        result += m_indentation;
    }
    result += line;
    return result;
}

std::string CodeGenerator::DataTypeToPythonType(VScriptDataType data_type) const {
    switch (data_type) {
        case VScriptDataType::Boolean:
            return "bool";
        case VScriptDataType::Integer:
            return "int";
        case VScriptDataType::Float:
            return "float";
        case VScriptDataType::String:
            return "str";
        case VScriptDataType::Vector2:
            return "tuple[float, float]";
        case VScriptDataType::Vector3:
            return "tuple[float, float, float]";
        case VScriptDataType::Object:
            return "object";
        case VScriptDataType::Any:
        default:
            return "Any";
    }
}

std::string CodeGenerator::GenerateVariableName(VScriptNode* node, const std::string& pin_name) const {
    if (!node) {
        return "unknown_var";
    }

    // Create a clean variable name from node ID and pin name
    std::string node_id = node->GetId();
    std::string clean_node_id = node_id;
    std::string clean_pin_name = pin_name;

    // Replace invalid characters with underscores
    for (char& c : clean_node_id) {
        if (!std::isalnum(c)) {
            c = '_';
        }
    }
    for (char& c : clean_pin_name) {
        if (!std::isalnum(c)) {
            c = '_';
        }
    }

    // For common pin names, use shorter variable names
    if (pin_name == "result" || pin_name == "value" || pin_name == "output") {
        return clean_node_id + "_" + clean_pin_name;
    } else if (pin_name == "exec_out") {
        return ""; // Execution pins don't need variables
    }

    return clean_node_id + "_" + clean_pin_name;
}

std::string CodeGenerator::FormatDefaultValue(const std::string& value, VScriptDataType data_type) const {
    if (value.empty()) {
        return "None";
    }

    switch (data_type) {
        case VScriptDataType::Boolean:
            // Convert to Python boolean
            if (value == "true" || value == "True" || value == "1") {
                return "True";
            } else if (value == "false" || value == "False" || value == "0") {
                return "False";
            }
            return value; // Assume it's already properly formatted

        case VScriptDataType::String:
            // Ensure string is properly quoted
            if (value.front() != '"' && value.front() != '\'') {
                return "\"" + value + "\"";
            }
            return value;

        case VScriptDataType::Integer:
        case VScriptDataType::Float:
            // Numbers should be used as-is
            return value;

        case VScriptDataType::Vector2:
            // Format as tuple (x, y)
            if (value.find(',') != std::string::npos) {
                return "(" + value + ")";
            }
            return "(0.0, 0.0)"; // Default vector2

        case VScriptDataType::Vector3:
            // Format as tuple (x, y, z)
            if (value.find(',') != std::string::npos) {
                return "(" + value + ")";
            }
            return "(0.0, 0.0, 0.0)"; // Default vector3

        case VScriptDataType::Object:
        case VScriptDataType::Any:
        default:
            return value;
    }
}

std::vector<std::string> CodeGenerator::GenerateInputAssignments(const VScriptGraph& graph,
                                                                 VScriptNode* node,
                                                                 int indent_level) const {
    std::vector<std::string> lines;

    if (!node) {
        return lines;
    }

    // Get all data input pins
    auto input_pins = node->GetDataInputPins();

    for (auto* pin : input_pins) {
        // Check if this pin has a connection
        auto connections = graph.GetConnectionsToPin(node->GetId(), pin->GetName());
        if (!connections.empty()) {
            // Generate assignment from connected output
            VScriptConnection* connection = connections[0];
            VScriptNode* source_node = graph.GetNode(connection->GetFromNodeId());
            if (source_node) {
                std::string source_var = GenerateVariableName(source_node, connection->GetFromPinName());
                std::string target_var = pin->GetName();

                if (!source_var.empty()) {
                    lines.push_back(ApplyIndentation(target_var + " = " + source_var, indent_level));
                }
            }
        } else {
            // Use default value
            std::string default_val = FormatDefaultValue(pin->GetDefaultValue(), pin->GetDataType());
            if (default_val != "None" && !default_val.empty()) {
                lines.push_back(ApplyIndentation(pin->GetName() + " = " + default_val, indent_level));
            }
        }
    }

    return lines;
}

std::vector<std::string> CodeGenerator::GenerateOutputAssignments(const VScriptGraph& graph,
                                                                  VScriptNode* node,
                                                                  int indent_level) const {
    std::vector<std::string> lines;

    if (!node) {
        return lines;
    }

    // Get all data output pins that have connections
    auto output_pins = node->GetDataOutputPins();

    for (auto* pin : output_pins) {
        auto connections = graph.GetConnectionsFromPin(node->GetId(), pin->GetName());
        if (!connections.empty()) {
            // This output is connected, so we need to ensure it has a variable
            std::string var_name = GenerateVariableName(node, pin->GetName());
            if (!var_name.empty() && pin->GetName() != "result") {
                // For non-result pins, we might need to assign the pin value to the variable
                // This depends on the node implementation
                if (m_include_debug_comments) {
                    lines.push_back(ApplyIndentation("# Output: " + pin->GetName() + " -> " + var_name, indent_level));
                }
            }
        }
    }

    return lines;
}

std::vector<std::string> CodeGenerator::GenerateNodeCode(const VScriptGraph& graph,
                                                         VScriptNode* node,
                                                         int indent_level) const {
    if (!node) {
        return {};
    }

    // For now, use the existing node code generation
    // In the future, this could be enhanced to pass graph context to nodes
    auto lines = node->GenerateCode(indent_level);

    // Post-process the lines to replace placeholders with actual connected values
    for (std::string& line : lines) {
        // Replace common placeholders with actual values
        ReplaceCodePlaceholders(graph, node, line);
    }

    return lines;
}

void CodeGenerator::ReplaceCodePlaceholders(const VScriptGraph& graph,
                                           VScriptNode* node,
                                           std::string& line) const {
    if (!node) {
        return;
    }

    // Get all input pins for this node
    auto input_pins = node->GetDataInputPins();

    for (auto* pin : input_pins) {
        std::string pin_name = pin->GetName();

        // Look for the pin name in the code line
        size_t pos = line.find(pin_name);
        if (pos != std::string::npos) {
            // Check if this pin has a connection
            auto connections = graph.GetConnectionsToPin(node->GetId(), pin_name);
            if (!connections.empty()) {
                // Replace with connected value
                VScriptConnection* connection = connections[0];
                VScriptNode* source_node = graph.GetNode(connection->GetFromNodeId());
                if (source_node) {
                    std::string source_var = GenerateVariableName(source_node, connection->GetFromPinName());
                    if (!source_var.empty()) {
                        // Replace all occurrences of the pin name with the source variable
                        size_t start_pos = 0;
                        while ((start_pos = line.find(pin_name, start_pos)) != std::string::npos) {
                            // Make sure we're replacing a whole word, not part of another word
                            bool is_word_boundary = true;
                            if (start_pos > 0) {
                                char prev_char = line[start_pos - 1];
                                if (std::isalnum(prev_char) || prev_char == '_') {
                                    is_word_boundary = false;
                                }
                            }
                            if (start_pos + pin_name.length() < line.length()) {
                                char next_char = line[start_pos + pin_name.length()];
                                if (std::isalnum(next_char) || next_char == '_') {
                                    is_word_boundary = false;
                                }
                            }

                            if (is_word_boundary) {
                                line.replace(start_pos, pin_name.length(), source_var);
                                start_pos += source_var.length();
                            } else {
                                start_pos += pin_name.length();
                            }
                        }
                    }
                }
            } else {
                // Replace with default value if no connection
                std::string default_val = FormatDefaultValue(pin->GetDefaultValue(), pin->GetDataType());
                if (default_val != "None" && !default_val.empty()) {
                    size_t start_pos = 0;
                    while ((start_pos = line.find(pin_name, start_pos)) != std::string::npos) {
                        // Check word boundaries
                        bool is_word_boundary = true;
                        if (start_pos > 0) {
                            char prev_char = line[start_pos - 1];
                            if (std::isalnum(prev_char) || prev_char == '_') {
                                is_word_boundary = false;
                            }
                        }
                        if (start_pos + pin_name.length() < line.length()) {
                            char next_char = line[start_pos + pin_name.length()];
                            if (std::isalnum(next_char) || next_char == '_') {
                                is_word_boundary = false;
                            }
                        }

                        if (is_word_boundary) {
                            line.replace(start_pos, pin_name.length(), default_val);
                            start_pos += default_val.length();
                        } else {
                            start_pos += pin_name.length();
                        }
                    }
                }
            }
        }
    }
}

} // namespace Lupine
