#include "lupine/export/EmbeddedLibraryManager.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>

// Include embedded library data (generated by build system)
#ifdef LUPINE_EMBED_LINUX_LIBRARIES
#include "embedded_linux_libraries.h"
#endif

#ifdef LUPINE_EMBED_WINDOWS_LIBRARIES
#include "embedded_windows_libraries.h"
#endif

namespace Lupine {

EmbeddedLibraryManager::EmbeddedLibraryManager() = default;

EmbeddedLibraryManager::~EmbeddedLibraryManager() = default;

bool EmbeddedLibraryManager::Initialize() {
    if (m_initialized) {
        return true;
    }

    try {
        LoadEmbeddedLibraries();
        m_initialized = true;
        
        std::cout << "Embedded Library Manager initialized with " 
                  << m_libraries.size() << " libraries" << std::endl;
        
        return true;
    } catch (const std::exception& e) {
        std::cerr << "Failed to initialize Embedded Library Manager: " << e.what() << std::endl;
        return false;
    }
}

bool EmbeddedLibraryManager::HasLibrariesForPlatform(const std::string& platform, 
                                                    const std::string& architecture) const {
    std::string platform_key = platform + "_" + architecture;
    return m_platform_libraries.find(platform_key) != m_platform_libraries.end();
}

bool EmbeddedLibraryManager::ExtractLibraries(const std::string& platform, 
                                             const std::string& architecture,
                                             const std::filesystem::path& output_dir) {
    if (!m_initialized && !Initialize()) {
        return false;
    }

    try {
        std::filesystem::create_directories(output_dir);
        
        std::string platform_key = platform + "_" + architecture;
        auto it = m_platform_libraries.find(platform_key);
        if (it == m_platform_libraries.end()) {
            std::cerr << "No libraries found for platform: " << platform_key << std::endl;
            return false;
        }

        bool all_success = true;
        for (const auto& lib_name : it->second) {
            std::string lib_key = CreateLibraryKey(lib_name, platform, architecture);
            auto lib_it = m_libraries.find(lib_key);
            if (lib_it == m_libraries.end()) {
                std::cerr << "Library not found: " << lib_key << std::endl;
                all_success = false;
                continue;
            }

            auto output_path = output_dir / (lib_name + ".a");
            std::filesystem::create_directories(output_path.parent_path());
            
            std::ofstream file(output_path, std::ios::binary);
            if (!file) {
                std::cerr << "Failed to create output file: " << output_path << std::endl;
                all_success = false;
                continue;
            }

            const auto& lib_data = lib_it->second->data;
            file.write(reinterpret_cast<const char*>(lib_data.data()), lib_data.size());
            file.close();

            if (!file.good()) {
                std::cerr << "Failed to write library data: " << output_path << std::endl;
                all_success = false;
                continue;
            }

            std::cout << "Extracted library: " << lib_name << " -> " << output_path << std::endl;
        }

        return all_success;
    } catch (const std::exception& e) {
        std::cerr << "Failed to extract libraries: " << e.what() << std::endl;
        return false;
    }
}

std::vector<std::string> EmbeddedLibraryManager::GetAvailableLibraries(const std::string& platform,
                                                                       const std::string& architecture) const {
    std::vector<std::string> libraries;
    
    for (const auto& [key, lib] : m_libraries) {
        if ((platform.empty() || lib->platform == platform) &&
            (architecture.empty() || lib->architecture == architecture)) {
            libraries.push_back(lib->name);
        }
    }
    
    // Remove duplicates and sort
    std::sort(libraries.begin(), libraries.end());
    libraries.erase(std::unique(libraries.begin(), libraries.end()), libraries.end());
    
    return libraries;
}

const EmbeddedLibrary* EmbeddedLibraryManager::GetLibraryInfo(const std::string& name,
                                                             const std::string& platform,
                                                             const std::string& architecture) const {
    std::string key = CreateLibraryKey(name, platform, architecture);
    auto it = m_libraries.find(key);
    return (it != m_libraries.end()) ? it->second.get() : nullptr;
}

bool EmbeddedLibraryManager::ExtractLibrary(const std::string& name, 
                                           const std::string& platform,
                                           const std::string& architecture,
                                           const std::filesystem::path& output_path) {
    if (!m_initialized && !Initialize()) {
        return false;
    }

    std::string key = CreateLibraryKey(name, platform, architecture);
    auto it = m_libraries.find(key);
    if (it == m_libraries.end()) {
        std::cerr << "Library not found: " << key << std::endl;
        return false;
    }

    try {
        std::filesystem::create_directories(output_path.parent_path());
        
        std::ofstream file(output_path, std::ios::binary);
        if (!file) {
            std::cerr << "Failed to create output file: " << output_path << std::endl;
            return false;
        }

        const auto& lib_data = it->second->data;
        file.write(reinterpret_cast<const char*>(lib_data.data()), lib_data.size());
        file.close();

        return file.good();
    } catch (const std::exception& e) {
        std::cerr << "Failed to extract library " << name << ": " << e.what() << std::endl;
        return false;
    }
}

bool EmbeddedLibraryManager::VerifyIntegrity() const {
    for (const auto& [key, lib] : m_libraries) {
        std::string calculated_checksum = CalculateChecksum(lib->data);
        if (calculated_checksum != lib->checksum) {
            std::cerr << "Integrity check failed for library: " << lib->name 
                      << " (expected: " << lib->checksum 
                      << ", got: " << calculated_checksum << ")" << std::endl;
            return false;
        }
    }
    return true;
}

size_t EmbeddedLibraryManager::GetTotalSize(const std::string& platform, 
                                           const std::string& architecture) const {
    size_t total_size = 0;
    
    for (const auto& [key, lib] : m_libraries) {
        if ((platform.empty() || lib->platform == platform) &&
            (architecture.empty() || lib->architecture == architecture)) {
            total_size += lib->size;
        }
    }
    
    return total_size;
}

bool EmbeddedLibraryManager::NeedsUpdate(const std::string& platform, 
                                        const std::string& architecture) const {
    // For now, always return false - in the future this could check version numbers
    // against a remote repository or local cache
    return false;
}

void EmbeddedLibraryManager::LoadEmbeddedLibraries() {
    bool loaded_any = false;

#ifdef LUPINE_EMBED_LINUX_LIBRARIES
    // Load Linux x64 libraries
    const auto& linux_libs = GetEmbeddedLinuxLibraries();

    std::vector<std::string> linux_lib_names;

    for (const auto& [name, data] : linux_libs) {
        auto lib = std::make_unique<EmbeddedLibrary>();
        lib->name = name;
        lib->platform = "linux";
        lib->architecture = "x64";
        lib->data = data;
        lib->size = data.size();
        lib->checksum = CalculateChecksum(data);
        lib->version = "1.0.0"; // TODO: Get actual version

        std::string key = CreateLibraryKey(name, "linux", "x64");
        m_libraries[key] = std::move(lib);

        linux_lib_names.push_back(name);
    }

    m_platform_libraries["linux_x64"] = linux_lib_names;

    std::cout << "Loaded " << linux_libs.size() << " embedded Linux libraries" << std::endl;
    loaded_any = true;
#endif

#ifdef LUPINE_EMBED_WINDOWS_LIBRARIES
    // Load Windows x64 libraries
    const auto& windows_libs = GetEmbeddedWindowsLibraries();

    std::vector<std::string> windows_lib_names;

    for (const auto& [name, data] : windows_libs) {
        auto lib = std::make_unique<EmbeddedLibrary>();
        lib->name = name;
        lib->platform = "windows";
        lib->architecture = "x64";
        lib->data = data;
        lib->size = data.size();
        lib->checksum = CalculateChecksum(data);
        lib->version = "1.0.0"; // TODO: Get actual version

        std::string key = CreateLibraryKey(name, "windows", "x64");
        m_libraries[key] = std::move(lib);

        windows_lib_names.push_back(name);
    }

    m_platform_libraries["windows_x64"] = windows_lib_names;

    std::cout << "Loaded " << windows_libs.size() << " embedded Windows libraries" << std::endl;
    loaded_any = true;
#endif

    if (!loaded_any) {
        std::cout << "No embedded libraries available (no LUPINE_EMBED_*_LIBRARIES defined)" << std::endl;
    }
}

std::string EmbeddedLibraryManager::CalculateChecksum(const std::vector<uint8_t>& data) const {
    // Simple checksum calculation (in production, use SHA-256 or similar)
    size_t checksum = 0;
    for (uint8_t byte : data) {
        checksum = checksum * 31 + byte;
    }
    
    std::stringstream ss;
    ss << std::hex << checksum;
    return ss.str();
}

std::string EmbeddedLibraryManager::CreateLibraryKey(const std::string& name,
                                                    const std::string& platform,
                                                    const std::string& architecture) const {
    return name + "_" + platform + "_" + architecture;
}

// Global instance
static EmbeddedLibraryManager g_embedded_library_manager;

EmbeddedLibraryManager& GetEmbeddedLibraryManager() {
    return g_embedded_library_manager;
}

} // namespace Lupine
